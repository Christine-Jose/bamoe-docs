= Overview of stateful Workflows

include::../partials/attributes.adoc[]

As a developer of business processes, you can use BAMOE to develop process services using Business Process Model and Notation (BPMN) 2.0 models. BPMN process models are graphical representations of the steps required to achieve a business goal. You can design your BPMN processes with {CANVAS} or the {}. Alternatively you can import existing BPMN processes into your BAMOE projects for deployment and execution. 

This technology preview enables you to go further in the BPMN workflows that you implement enabling you to use new elements such as process variables, events, timers,  human tasks and asynchronous tasks (service, decision, script). 

This section also introduces the key concepts of the new Compact Architecture where certain services can be colocated directly in the Runtime. This architecture simplifies the application configuration and minimizes the communication between components which ensures that {PRODUCT_SHORT} applications are stable and robust in a Business Process environment. 

== Compact architecture 
Compact architecture is a way to enable a process to run everything in an integrated way within the same
deployment. In this architecture the communication with required or optional subsystems is via internal VM
communication. Here are some basic definitions:

Deployment:: is considered to be a consistent functional program that provides a set of defined functionalities that enable workflow execution.

Stateful Workflow:: is a process that is able to persist its instance state into a database or other type of storage. It may include user tasks, timers, be long-running, have data tracking and auditing.

Stateless Workflow or Straight-Through Process (STP):: is a Workflow whose instance state is not stored in database. A stateless Workflow is executed in one transaction, does not have data persistence, timers or User Tasks. Stateless Workflows are a subset of stateful Workflows.

.The different components of Compact Architecture
image::../images/wf-compact-arch.png[]

The following table shows the mandatory components in the subsystem of the compact architecture to implement a stateful workflow.

[%header,cols="4"]
|===
^|Subsystem 
^|Type 
^|Stateful process (compact) 
^|Stateless (STP) 

|Workflow engine | System | mandatory | mandatory 
|Jobs | Addon | mandatory | N/A
|Human task | Addon | mandatory | N/A
|Storage/persistence | System | mandatory | N/A
|Data-Index | Addon | optional | N/A
|Data audit | Addon | optional | N/A
|===

== Component description

=== System
Runtime:: This is the infrastructure providing basic services required for running a complex application: transactions, rest infraestructure (JAX-RS), jdbc pool, thread pools, escalability, security, DI (dependency injection). The runtime relies on Quarkus.

Workflow engine:: The kogito API + jBPM workflow engine provides the workflow execution environment using kogito APIs and implementations.

Process container:: This is the BPMN file compiled and wired in to the workflow engine.

=== Addons
Jobs:: allows the execution of timed events. In the case of BPMN and workflows it is required for timers, deadlines, and notifications. 

Data audit:: allows the inspection of what happened during workflow execution. It should be able to replay the process. The system stores all diff event data comming from events.

Data-Index:: allows the last snapshot of the process state to be queried. The workflow engine sends diff events and Data-Index computes the last state by merging current data with the diff event data.

User Task:: is a subsystem that allows human tasks to be executed. It provides a lifecycle internally. This should not be confused with a user task node in the workflow. The user task node uses this subsystem to implement user tasks.

Process mangement:: is a subsystem ...

=== Required deployments
Storage:: This is another deployment. In our case would be PostgreSQL database where we are going to store the process state, jobs, Data-Index, data audit and human task data. There can only be one storage that is shared among components and cannot be divided.




