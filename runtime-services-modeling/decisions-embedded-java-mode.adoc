= Decisions Embedded Java mode
include::../partials/attributes.adoc[]

This documentation is a simplified version of the community documentation available as https://docs.drools.org/8.44.0.Final/drools-docs/drools/KIE/index.html.

Building Drools-based KIE project make use of Maven, and aligns with Maven practices.
A KIE project or module is simply a Maven Java project or module; with an additional metadata file `META-INF/kmodule.xml`.
The `kmodule.xml` file is the descriptor that selects resources to KIE bases and configures those KIE bases and sessions.
We explain those later in this document.

While standard Maven can build and package KIE resources, it will not provide validation at build time.
There is a Maven plugin (`kie-maven-plugin`) which is recommended to use to get build time validation.
The plugin also generates many classes, making the runtime loading faster too.

== kmodule.xml
Since meaningful defaults have been provided for all configuration aspects, the simplest `kmodule.xml` file can contain just an empty kmodule tag like the following:

.An empty kmodule.xml example
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<kmodule xmlns="http://www.drools.org/xsd/kmodule"/>
----

In this way the kmodule will contain one single default `KieBase`.
All KIE assets stored under the resources folder, or any of its subfolders, will be compiled and added to it.
To trigger the building of these artifacts it is enough to create a `KieContainer` for them.

.Creating a KieContainer that reads the files to be built from the classpath
[source,java]
----
KieServices kieServices = KieServices.Factory.get();
KieContainer kContainer = kieServices.getKieClasspathContainer();
----

`KieServices` is the interface from where it is possible to access all the KIE building and runtime facilities.
In the code above, all the Java sources and the KIE resources are compiled and deployed into the `KieContainer` which makes its contents available for use at runtime.

The `kmodule.xml` allows to define and configure one or more `KieBase` s and for each `KieBase` all the different `KieSession` s that can be created from it, as showed by the follwing example:

// TODO probably too complex example?
.A kmodule.xml example
[source,xml]
----
<kmodule xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://www.drools.org/xsd/kmodule">
  <configuration>
    <property key="drools.evaluator.supersetOf" value="org.mycompany.SupersetOfEvaluatorDefinition"/>
  </configuration>
  <kbase name="KBase1" default="true" eventProcessingMode="cloud" equalsBehavior="equality" declarativeAgenda="enabled" packages="org.domain.pkg1">
    <ksession name="KSession2_1" type="stateful" default="true"/>
    <ksession name="KSession2_2" type="stateless" default="false" beliefSystem="jtms"/>
  </kbase>
  <kbase name="KBase2" default="false" eventProcessingMode="stream" equalsBehavior="equality" declarativeAgenda="enabled" packages="org.domain.pkg2, org.domain.pkg3" includes="KBase1">
    <ksession name="KSession3_1" type="stateful" default="false" clockType="realtime">
      <fileLogger file="drools.log" threaded="true" interval="10"/>
      <workItemHandlers>
        <workItemHandler name="name" type="org.domain.WorkItemHandler"/>
      </workItemHandlers>
      <calendars>
        <calendar name="monday" type="org.domain.Monday"/>
      </calendars>
      <listeners>
        <ruleRuntimeEventListener type="org.domain.RuleRuntimeListener"/>
        <agendaEventListener type="org.domain.FirstAgendaListener"/>
        <agendaEventListener type="org.domain.SecondAgendaListener"/>
        <processEventListener type="org.domain.ProcessListener"/>
      </listeners>
    </ksession>
  </kbase>
</kmodule>
----


NOTE: You can find more about `kmodule.xml` configuration options https://docs.drools.org/8.44.0.Final/drools-docs/drools/KIE/index.html#_thekmodulexmlfile[here].


Having defined a `kmodule.xml` like the one in the former sample, it is now possible to simply retrieve the `KieBase` s and `KieSession` s from the `KieContainer` using their names.

[source,java]
----
KieServices kieServices = KieServices.Factory.get();
KieContainer kContainer = kieServices.getKieClasspathContainer();

KieBase kBase1 = kContainer.getKieBase("KBase1");
KieSession kieSession1 = kContainer.newKieSession("KSession2_1");
StatelessKieSession kieSession2 = kContainer.newStatelessKieSession("KSession2_2");
----

It is also possible to create `KieContainer` containing all assets of the project using the project `GAV`.

[source,java]
----
KieServices kieServices = KieServices.Factory.get();
ReleaseId releaseId = kieServices.newReleaseId("org.acme", "myartifact", "1.0");
KieContainer kieContainer = kieServices.newKieContainer(releaseId);
----

== kie-maven-plugin
To run decision in embedded java mode, we will need to use `kie-maven-plugin` in our project.
Please update your `pom.xml` in this way.

// TODO is 9.1.0.rc2-ibm-0001 the final to use?
[source,xml]
----
  <packaging>kjar</packaging>
  ...
  <build>
    <plugins>
      <plugin>
        <groupId>org.kie</groupId>
        <artifactId>kie-maven-plugin</artifactId>
        <version>9.1.0.rc2-ibm-0001</version>
        <extensions>true</extensions>
      </plugin>
    </plugins>
  </build>
----

== DRL based rules execution
To execute DRL based rules in java, we need to understand KIE API.

=== KieBase
The `KieBase` is a repository of all the application\'s knowledge definitions.
It will contain rules, processes, functions, and type models.
The `KieBase` itself does not contain data; instead, sessions are created from the `KieBase` into which data can be inserted and from which process instances may be started.
The `KieBase` can be obtained from the `KieContainer` containing the `KieModule` where the `KieBase` has been defined.


[source,java]
----
KieBase kBase = kContainer.getKieBase();
----

=== KieSession
The `KieSession` stores and executes on the runtime data.
It is created from the `KieBase`.

[source,java]
----
KieSession ksession = kbase.newKieSession();
----

=== KieRuntime
The `KieRuntime` provides methods that are applicable to both rules and processes, such as setting globals and registering channels.
("Exit point" is an obsolete synonym for "channel".)

==== Globals
Globals are named objects that are made visible to the Drools rule engine, but in a way that is fundamentally different from the one for facts: changes in the object backing a global do not trigger reevaluation of rules.
Still, globals are useful for providing static information, as an object offering services that are used in the RHS of a rule, or as a means to return objects from the Drools rule engine.
When you use a global on the LHS of a rule, make sure it is immutable, or, at least, don\'t expect changes to have any effect on the behavior of your rules.

A global must be declared in a rules file, and then it needs to be backed up with a Java object.

[source]
----
global java.util.List list
----

With the KIE base now aware of the global identifier and its type, it is now possible to call `ksession.setGlobal()` with the global\'s name and an object, for any session, to associate the object with the global.
Failure to declare the global type and identifier in DRL code will result in an exception being thrown from this call.

[source,java]
----
List<String> list = new ArrayList<>();
ksession.setGlobal("list", list);
----

Make sure to set any global before it is used in the evaluation of a rule.
Failure to do so results in a `NullPointerException`.

=== Event Model
The event package provides means to be notified of Drools rule engine events, including rules firing, objects being asserted, etc.
This allows separation of logging and auditing activities from the main part of your application (and the rules).

The `KieRuntimeEventManager` interface is implemented by the `KieRuntime` which provides two interfaces, `RuleRuntimeEventManager` and `ProcessEventManager`.
We will only cover the `RuleRuntimeEventManager` here.

The `RuleRuntimeEventManager` allows for listeners to be added and removed, so that events for the working memory and the agenda can be listened to.

The following code snippet shows how a simple agenda listener is declared and attached to a session.
It will print matches after they have fired.

[source,java]
----
ksession.addEventListener(new DefaultAgendaEventListener() {
    public void afterMatchFired(AfterMatchFiredEvent event) {
        super.afterMatchFired(event);
        System.out.println(event);
    }
});
----

Drools also provides `DebugRuleRuntimeEventListener` and `DebugAgendaEventListener` which implement each method with a debug print statement.
To print all Working Memory events, you add a listener like this:

[source,java]
----
ksession.addEventListener(new DebugRuleRuntimeEventListener());
----

All emitted events implement the `KieRuntimeEvent` interface which can be used to retrieve the actual `KnowlegeRuntime` the event originated from.

// TODO what branch/tag to use ? 999-20240521?
NOTE: To see available events browse `org.kie.api.event.rule` https://github.com/apache/incubator-kie-drools/tree/999-20240521/kie-api/src/main/java/org/kie/api/event/rule[package].


=== KieRuntimeLogger
The `KieRuntimeLogger` uses the comprehensive event system in Drools to create an audit log that can be used to log the execution of an application for later inspection.

[source,java]
----
KieRuntimeLogger logger =
  KieServices.Factory.get().getLoggers().newFileLogger(ksession, "logdir/mylogfile");
// ... ksession in action ...
logger.close();
----

=== Commands and the CommandExecutor
KIE has the concept of stateful or stateless sessions.
Stateful sessions can be worked with iteratively over time.
Stateless is a one-off execution of a `KieRuntime` with a provided data set.
It may return some results, with the session being disposed at the end, prohibiting further iterative interactions.
You can think of stateless as treating an engine like a function call with optional return results.

The foundation for this is the `CommandExecutor` interface, which both the stateful and stateless interfaces extend.
This returns an https://github.com/apache/incubator-kie-drools/blob/999-20240521/kie-api/src/main/java/org/kie/api/runtime/ExecutionResults.java[`ExecutionResults`].
// TODO should I link all mentions of KIE classes in similar way ^ ?

The `CommandExecutor` allows for commands to be executed on those sessions, the only difference being that the `StatelessKieSession` executes `fireAllRules()` at the end before disposing the session.
The commands can be created using the https://github.com/apache/incubator-kie-drools/blob/999-20240521/kie-internal/src/main/java/org/kie/internal/command/CommandFactory.java[`CommandFactory`].

//TODO replace with some non cheese example, more business like
[source,java]
----
StatelessKieSession ksession = kbase.newStatelessKieSession();
ExecutionResults results =
    ksession.execute(CommandFactory.newSetGlobal("stilton", new Cheese("stilton"), true);
Cheese stilton = results.getValue("stilton");
----

The previous example executes a single command.
The `BatchExecution` represents a composite command, created from a list of commands.
It will iterate over the list and execute each command in turn.
This means you can insert some objects, start a process, call `fireAllRules` and execute a query, all in a single `execute(…​)` call, which is quite powerful.

The `StatelessKieSession` will execute `fireAllRules()` automatically at the end.
However the keen-eyed reader probably has already noticed the `FireAllRules` command and wondered how that works with a `StatelessKieSession`.
The `FireAllRules` command is allowed, and using it will disable the automatic execution at the end; think of using it as a sort of manual override function.

Any command, in the batch, that has an out identifier set will add its results to the returned `ExecutionResults` instance.
Let\'s look at a simple example to see how this works.

// TODO replace chceese example with more business like
[source,java]
----
StatelessKieSession ksession = kbase.newStatelessKieSession();

List cmds = new ArrayList();
cmds.add(CommandFactory.newInsertObject(new Cheese("stilton", 1), "stilton"));
cmds.add(CommandFactory.newStartProcess("process cheeses"));
cmds.add(CommandFactory.newQuery("cheeses"));
ExecutionResults bresults = ksession.execute(CommandFactory.newBatchExecution(cmds));
Cheese stilton = (Cheese) bresults.getValue("stilton");
QueryResults qresults = (QueryResults) bresults.getValue("cheeses");
----

In the previous example multiple commands are executed, two of which populate the `ExecutionResults`.
The query command defaults to use the same identifier as the query name, but it can also be mapped to a different identifier.

=== StatelessKieSession
The `StatelessKieSession` wraps the `KieSession`, instead of extending it.
Its main focus is on the decision service type scenarios.
It avoids the need to call `dispose()`.
Stateless sessions do not support iterative insertions and the method call `fireAllRules()` from Java code; the act of calling `execute()` is a single-shot method that will internally instantiate a `KieSession`, add all the user data and execute user commands, call `fireAllRules()`, and then call `dispose()`.
While the main way to work with this class is via the `BatchExecution` (a subinterface of `Command`) as supported by the `CommandExecutor` interface, two convenience methods are provided for when simple object insertion is all that\'s required.

Our simple example shows a stateless session executing a given collection of Java objects using the convenience API.
It will iterate the collection, inserting each element in turn.

// TODO check if this snippet would be working with real `collection`
[source,java]
----
StatelessKieSession ksession = kbase.newStatelessKieSession();
ksession.execute(collection);
----

If this was done as a single `Command` it would be as follows:

// TODO check the code snippet
[source,java]
----
ksession.execute(CommandFactory.newInsertElements(collection));
----

If you wanted to insert the collection itself, and the collection\'s individual elements, then `CommandFactory.newInsert(collection)` would do the job.

Methods of the `CommandFactory` create the supported commands, all of which can be marshalled using XStream and the `BatchExecutionHelper`.
`BatchExecutionHelper` provides details on the XML format as well as how to use Drools Pipeline to automate the marshalling of `BatchExecution` and `ExecutionResults`.

`StatelessKieSession` supports globals, scoped in a number of ways.
We cover the non-command way first, as commands are scoped to a specific execution call.
Globals can be resolved in three ways.

The `StatelessKieSession` method `getGlobals()` returns a Globals instance which provides access to the session's globals.
These are used for all execution calls.
Exercise caution regarding mutable globals because execution calls can be executing simultaneously in different threads.

.Session scoped global example
[source,java]
----
StatelessKieSession ksession = kbase.newStatelessKieSession();
// Set a global hbnSession, that can be used for DB interactions in the rules.
ksession.setGlobal("hbnSession", hibernateSession);
// Execute while being able to resolve the "hbnSession" identifier.
ksession.execute(collection);
----

Using a delegate is another way of global resolution.
Assigning a value to a global (with `setGlobal(String, Object)`) results in the value being stored in an internal collection mapping identifiers to values.
Identifiers in this internal collection will have priority over any supplied delegate.
Only if an identifier cannot be found in this internal collection, the delegate global (if any) will be used.

The third way of resolving globals is to have execution scoped globals.
Here, a `Command` to set a global is passed to the `CommandExecutor`.

The `CommandExecutor` interface also offers the ability to export data via "out" parameters.
Inserted facts, globals and query results can all be returned.

.Out identifiers example
[source,java]
----
// Set up a list of commands
List cmds = new ArrayList();
cmds.add(CommandFactory.newSetGlobal("list1", new ArrayList(), true));
cmds.add(CommandFactory.newInsert(new Person("jon", 102), "person"));
cmds.add(CommandFactory.newQuery("Get People", "getPeople"));

// Execute the list
ExecutionResults results =
  ksession.execute(CommandFactory.newBatchExecution(cmds));

// Retrieve the ArrayList
results.getValue("list1");
// Retrieve the inserted Person fact
results.getValue("person");
// Retrieve the query as a QueryResults instance.
results.getValue("Get People");
----

== DMN model execution
You can create or import DMN files in your Drools project using KIE DMN Editor or package the DMN files as part of your project knowledge JAR (KJAR) file without KIE DMN Editor.

After you implement your DMN files in your Drools project, you can execute the DMN decision service by instantiating a KIE container that contains it directly as a dependency of the calling application.
Other options for creating and deploying DMN knowledge packages are also available, and most are similar for all types of knowledge assets, such as DRL files or process definitions.

Alternatively, you could package your DMN files as part of a Kogito cloud-native microservice.

For information about including external DMN assets with your project packaging and deployment method, see the Build, Deploy, Utilize and Run section.

A KIE container is local when the knowledge assets are either embedded directly into the calling program or are physically pulled in using Maven dependencies for the KJAR.
You typically embed knowledge assets directly into a project if there is a tight relationship between the version of the code and the version of the DMN definition.
Any changes to the decision take effect after you have intentionally updated and redeployed the application.
A benefit of this approach is that proper operation does not rely on any external dependencies to the run time, which can be a limitation of locked-down environments.

Using Maven dependencies enables further flexibility because the specific version of the decision can dynamically change, (for example, by using a `kmodule.xml` or a system property), and it can be periodically scanned for updates and automatically updated.
This introduces an external dependency on the deploy time of the service, but executes the decision locally, reducing reliance on an external service being available during run time.

=== Prerequisites
You have built the DMN project as a KJAR artifact and deployed it to a Maven repository, or you have included your DMN assets as part of your project classpath:

[source,bash]
----
mvn clean install
----

=== Procedure
In your client application, add the following dependencies to the relevant classpath of your Java project:

[source,xml]
----
<!-- Required for the DMN runtime API -->
<dependency>
  <groupId>org.kie</groupId>
  <artifactId>kie-dmn-core</artifactId>
  <version>9.1.0.rc2-ibm-0001</version>
</dependency>

<!-- Required if not using classpath KIE container -->
<dependency>
  <groupId>org.kie</groupId>
  <artifactId>kie-ci</artifactId>
  <version>9.1.0.rc2-ibm-0001</version>
</dependency>
----

Instead of specifying a Drools `<version>` for individual dependencies, consider adding the Drools bill of materials (BOM) dependency to dependencyManagement section of your project pom.xml file.
When you add the BOM files, the correct versions of transitive dependencies from the provided Maven repositories are included in the project.

.Example BOM dependency:
[source,xml]
----
<dependency>
  <groupId>org.kie</groupId>
  <artifactId>kie-dmn-bom</artifactId>
  <version>9.1.0.rc2-ibm-0001</version>
  <scope>import</scope>
  <type>pom</type>
</dependency>
----

.Create a KIE container from classpath or ReleaseId:
[source,java]
----
KieServices kieServices = KieServices.Factory.get();

ReleaseId releaseId = kieServices.newReleaseId( "org.acme", "my-kjar", "1.0.0" );
KieContainer kieContainer = kieServices.newKieContainer( releaseId );
----

.Alternative option:
[source,java]
----
KieServices kieServices = KieServices.Factory.get();

KieContainer kieContainer = kieServices.getKieClasspathContainer();
----

.Obtain `DMNRuntime` from the KIE container and a reference to the DMN model to be evaluated, by using the model namespace and modelName:
[source,java]
----
DMNRuntime dmnRuntime = KieRuntimeFactory.of(kieContainer.getKieBase()).get(DMNRuntime.class);

String namespace = "http://www.redhat.com/_c7328033-c355-43cd-b616-0aceef80e52a";
String modelName = "dmn-movieticket-ageclassification";

DMNModel dmnModel = dmnRuntime.getModel(namespace, modelName);
----
.Execute the decision services for the desired model:
[source,java]
----
DMNContext dmnContext = dmnRuntime.newContext();  

for (Integer age : Arrays.asList(1,12,13,64,65,66)) {
    dmnContext.set("Age", age);  
    DMNResult dmnResult =
        dmnRuntime.evaluateAll(dmnModel, dmnContext);  

    for (DMNDecisionResult dr : dmnResult.getDecisionResults()) {  
        log.info("Age: " + age + ", " +
                 "Decision: '" + dr.getDecisionName() + "', " +
                 "Result: " + dr.getResult());
  }
}
----

Instantiate a new DMN Context to be the input for the model evaluation.
Note that this example is looping through the Age Classification decision multiple times.
Assign input variables for the input DMN context.
Evaluate all DMN decisions defined in the DMN model.
Each evaluation may result in one or more results, creating the loop.
This example prints the following output:

[source,bash]
----
Age 1 Decision 'AgeClassification' : Child
Age 12 Decision 'AgeClassification' : Child
Age 13 Decision 'AgeClassification' : Adult
Age 64 Decision 'AgeClassification' : Adult
Age 65 Decision 'AgeClassification' : Senior
Age 66 Decision 'AgeClassification' : Senior
----